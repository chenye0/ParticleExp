<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Exp - PlaywithShader</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #ffffff;
				/*background-color: #000000;*/
				margin: 0px;
				overflow: hidden;
			}
			#info {
				position: absolute;
				top: 0px;
				width: 100%;
				padding: 5px;
				font-family: Monospace;
				font-size: 13px;
				text-align: center;
				font-weight: bold;
			}
			#container {
				position: absolute;
				width: 100%;
				height: 100%;
				overflow: hidden;
				/*background: linear-gradient(#dbe6f6, #c5796d);*/

			}
			a {
				color: #fff;
			}
			button {
				position: fixed;
				z-index: 10;
				background-color: #c5796d; /* Green */
			    border: none;
			    color: white;
			    padding: 15px 15px;
			    text-align: center;
			    text-decoration: none;
			}
		</style>
	</head>

	<body>
		<button type="button" onclick="switchScene()">Switch Scene</button>
		<div id="container"></div>

		<script src="../three.js-dev/build/three.js"></script>
		<script type="text/javascript" src="../BlenderThreejs/OrbitControls.js"></script>
		<script src="../three.js-dev/examples/js/Detector.js"></script>
		<script src="../three.js-dev/examples/js/libs/stats.min.js"></script>

		<script type="x-shader/x-vertex" id="vertexshader">

			uniform float time;
			attribute vec3 refer;
			attribute vec3 customColor;
			attribute vec3 selfspeed;
			attribute vec3 rotation;
			attribute float rspeed;
			attribute float life;
			uniform vec3 winddir;
			uniform float windspeed;

			varying vec2 vUv;
			// varying float life;
			varying vec3 vColor;
			// varying vec3 vRotation;
			vec3 rotateX(vec3 pos, float alpha) {
			    mat4 trans= mat4(   1.0, 0.0, 0.0, 0.0, 
			                        0.0, cos(alpha), -sin(alpha), 0.0, 
			                        0.0, sin(alpha), cos(alpha), 0.0, 
			                        0.0, 0.0, 0.0, 1.0);
			    return vec3(trans * vec4(pos, 1.0));
			}

			vec3 rotateZ(vec3 pos, float alpha) {
			    mat4 trans= mat4(   cos(alpha), -sin(alpha), 0.0, 0.0, 
			                        sin(alpha), cos(alpha), 0.0, 0.0, 
			                        0.0, 0.0, 1.0, 0.0, 
			                        0.0, 0.0, 0.0, 1.0);
			    return vec3(trans * vec4(pos, 1.0));
			}

			vec3 rotateY(vec3 pos, float alpha) {
			    mat4 trans= mat4(   cos(alpha), 0.0, sin(alpha), 0.0, 
			                        0.0, 1.0, 0.0, 0.0, 
			                        -sin(alpha), 0.0, cos(alpha), 0.0, 
			                        0.0, 0.0, 0.0, 1.0);
			    return vec3(trans * vec4(pos, 1.0));
			}

			void main() {
			    // float ra = 1.0*sin(time);
			    vec3 windshift = vec3 ( life * 0.03 * sin(life * winddir.x), life * winddir.z, cos(life * winddir.x) * life  * 0.03);
			    vec3 selfshift = life * selfspeed;
				vec3 r = life * rspeed * rotation;
				vColor = customColor;
				vUv = uv;
				vec3 translated = position;
				vec3 rotated =  rotateX(translated, r.x);
				rotated =  rotateY(rotated, r.y);
				rotated =  rotateZ(rotated, r.z);
				translated = rotated + refer;
				vec3 finalPos = translated + windshift + selfshift;
				vec4 mvPosition = modelViewMatrix * vec4( finalPos, 1.0 );
				// gl_PointSize = 30.0 * ( 300.0 / -mvPosition.z );
				gl_Position = projectionMatrix * mvPosition;

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshader">

			uniform vec3 color;
			uniform sampler2D texture;

			varying vec3 vColor;
			varying vec2 vUv;

			void main() {
				float mid = 0.5;

				gl_FragColor = vec4( 1.0,1.0,1.0, 1.0 );
				gl_FragColor = gl_FragColor * texture2D( texture, vUv);

			}

		</script>
		<script type="application/x-glsl" id="sky-vertex">  
			varying vec2 vUV;

			void main() {  
			  vUV = uv;
			  vec4 pos = vec4(position, 1.0);
			  gl_Position = projectionMatrix * modelViewMatrix * pos;
			}
		</script>
		<script type="application/x-glsl" id="sky-fragment">  
			uniform sampler2D texture;  
			varying vec2 vUV;

			void main() {  
			  vec4 sample = texture2D(texture, vUV);
			  gl_FragColor = vec4(sample.xyz, sample.w);
			}
		</script>  

		<script>

		if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

		var renderer, scene, camera, stats;

		var particleSystem, uniforms, geometry, seaPlane, skyuniforms;
		var group = new THREE.Group();
		var texture = ['Assets/snowflake1.png', 'myleaf.png', 'flower.png'];
		var Idx = 2, space =false;

		var particles = 1300;

		var WIDTH = window.innerWidth;
		var HEIGHT = window.innerHeight;

		init();
		animate();
		function createLights() {
			hemisphereLight = new THREE.HemisphereLight(0xffffff,0xffffff, .9);

			hemisphereLight.position.set( 0, 0, 0);
			shadowLight = new THREE.DirectionalLight(0xffffff, 4);
			shadowLight.color.setHSL( 0.1, 1, 0.95 );
			shadowLight.position.set(-15, 20, 20);
			shadowLight.target.position.set(0, 20, 0);
			// shadowLight.castShadow = true;
			scene.add(hemisphereLight);
			scene.add(shadowLight);
		}
		function switchScene() {
			console.log(Idx);
			Idx < 2 ? Idx += 1 : Idx = 0;
			uniforms.texture.value = new THREE.TextureLoader().load( texture[Idx] );
			skyuniforms.texture.value = new THREE.TextureLoader().load( 'Assets/night.jpg' );
			particleSystem.material.needsUpdate = true;
		}

		var posMouse = [];
		function onDocumentMouseDown(e) {
			posMouse = [e.clientX, e.clientY];
		}
		function onDocumentMouseUp(e) { 
			// if (posMouse.length > 0) {
			var c = [e.clientX - posMouse[0], e.clientY - posMouse[1]];
			var len = Math.sqrt(c[0]*c[0] + c[1]*c[1]);
			
						//console.log(uniforms.winddir.value);
			uniforms.winddir.value.x = c[0] * 0.03 / len;
			uniforms.winddir.value.y = - c[1] * 0.03 / len;

			// for (var i = 0, i6 = 0; i < particles * 6; i ++, i6 += 6 ) {
			// 	// console.log(positions[i3]);
			// 	plifes[i6] += 0.5;
			// 	plifes[i6 + 1] += 0.5;
			// 	plifes[i6 + 2] += 0.5;
			// 	plifes[i6 + 3] += 0.5;
			// 	plifes[i6 + 4] += 0.5;
			// 	plifes[i6 + 5] += 0.5;
				
			// 	// positions[i3 + 2] +=0.3;
			// 	// positions[ i3 + 1 ] = (positions[ i3 + 1 ] > HEIGHT)?  : positions[i3+1]-0.5;
			// 	// rotations[i] += 0.05;
			// }
			// // geometry.attributes.position.needsUpdate = true;
			// geometry.attributes.selfspeed.needsUpdate = false;
		}

		function init() {
			camera = new THREE.PerspectiveCamera( 40, WIDTH / HEIGHT, 1, 10000 );
			camera.position.z = 200;
			camera.position.y = 80;

			scene = new THREE.Scene();
			//Sea
			var mat = new THREE.MeshPhongMaterial({
				color:0x666666,
				transparent:false,
				opacity:0.8,
				shading:THREE.FlatShading
				// side: THREE.DoubleSide
			});
			var seageom = new THREE.PlaneGeometry(500, 500, 40, 40);
			// get the vertices
			var l = seageom.vertices.length;
			var waves = [];
			for (var i=0; i<l; i++){
				// get each vertex
				var v = seageom.vertices[i];
				//store some data associated to it
				waves.push({y:v.y,
							 x:v.x,
							 z:v.z,
							 // a random angle
							 ang:Math.random()*Math.PI*2,
							 // a random distance
							 amp:Math.random()*1,
							 // a random speed between 0.016 and 0.048 radians / frame
							 speed:0.016 + Math.random()*0.032
							});
			};

			seaPlane = new THREE.Mesh(seageom, mat);
			seaPlane.rotation.x = -90 * Math.PI/180;
			// seaPlane.position.y = -20;
			for (var i=0; i<l; i++) {
				var v = seageom.vertices[i];
				var vprops = waves[i];
				v.y = vprops.y + Math.cos(vprops.ang)*vprops.amp;
				v.z = vprops.z + Math.sin(vprops.ang)*vprops.amp;
			}	

			scene.add(seaPlane);
			
			//Save For Loading Background image
			// var loader = new THREE.TextureLoader();
   //          var texture = loader.load( 'assets/bg.jpg' );
   //          var backgroundMesh = new THREE.Mesh(
   //              new THREE.PlaneGeometry(300, 300, 0),
   //              new THREE.MeshBasicMaterial({
   //                  map: texture
   //              }));
   //          backgroundMesh.position.z = -100;
	  //       backgroundMesh.material.depthTest = false;
	  //       backgroundMesh.material.depthWrite = true;

	  //       // Create your background scene
	  //       // scene.add(backgroundCamera );
	  //       scene.add(backgroundMesh );
			// scene.background = new THREE.Color( 0x000);

			var skyGeo = new THREE.SphereGeometry(200, 40, 25); 
			skyuniforms = {  
			  texture: { type: 't', value: THREE.ImageUtils.loadTexture('Assets/winter.jpg') }
			};
			var skymat = new THREE.ShaderMaterial( {  
				uniforms:       skyuniforms,
				vertexShader:   document.getElementById('sky-vertex').textContent,
				fragmentShader: document.getElementById('sky-fragment').textContent
			});

			var skyBox = new THREE.Mesh(skyGeo, skymat);
		    skyBox.scale.set(-1, 1, 1);  
			skyBox.eulerOrder = 'XZY';  
			skyBox.renderDepth = 1000.0;  
			scene.add(skyBox); 


			uniforms = {
				time: { value: 10.0 },
				winddir: { value: new THREE.Vector3( 0.04, 5, 0.1) },
				windspeed: { value: 2 },
				color:     { value: new THREE.Color( 0xffffff ) },
				texture:   { value: new THREE.TextureLoader().load( texture[2] ), transparent: true, opacity: 0.1 }
			};

			var shaderMaterial = new THREE.ShaderMaterial( {

				uniforms:       uniforms,
				vertexShader:   document.getElementById( 'vertexshader' ).textContent,
				fragmentShader: document.getElementById( 'fragmentshader' ).textContent,

				// blending:       THREE.AdditiveBlending,
				side:           THREE.DoubleSide,
				depthTest:      false,
				transparent:    true

			});

			var radius = 200;
			var triangles = particles * 2;
			var vertex = triangles * 3;

			geometry = new THREE.BufferGeometry();

			var color = new THREE.Color(0xffcc99);
			var positions = new Float32Array( vertex * 3); 
			var colors = new Float32Array( vertex * 3);
			var uvs = new Float32Array ( vertex * 2);
			var rotations = new Float32Array( vertex * 3 ); // vertex / 2
			var rspeed = new Float32Array( vertex);
			var life = new Float32Array( vertex);
			var selfspeed = new Float32Array( vertex * 3 ); // vertex / 2
  			var reference = new Float32Array( vertex * 3);

			function verts_push(p, arr) {
				var v = p * 18;
				for (var i=0; i < arr.length; i++) {
					positions[v++] = arr[i];
				}
			}
			function uvs_push(p, arr) {
				var v = p * 12;
				for (var i=0; i < arr.length; i++) {
					uvs[v++] = arr[i];
				}
			}
			function getRandom(min, max) {
			    return Math.random() * (max - min) + min;
			}

			for (var i = 0, i6 = 0; i < particles; i ++, i6+= 18) {
				var tmpr = [getRandom(-1.0, 1.0), 0, getRandom(-1, 1)];
				var tmprs = getRandom(-0.1, 0.1);
				var selfs = [getRandom(-0.01, 0.01), getRandom(-0.01, 0.01), getRandom(-0.01, 0.01)];
				// var initpos = [getRandom(-20.0, 20.0), getRandom(10.0, 20.0), getRandom(-10.0, 10.0)],
				var initpos = [getRandom(-10.0, 10.0),getRandom(-10.0, -15.0),getRandom(-10.0, 10.0)],
					plife = getRandom(100, 2000);
				var size =  1;


				for (var j =0, j3 = 0; j < 6; j ++, j3 += 3) {
					rotations[i6 + j3    ] =  tmpr[0];
					rotations[i6 + j3 + 1] =  tmpr[1];
					rotations[i6 + j3 + 2] =  tmpr[2];

					selfspeed[i6 + j3    ] =  selfs[0];
					selfspeed[i6 + j3 + 1] =  selfs[1];
					selfspeed[i6 + j3 + 2] =  selfs[2];

					reference[ i6 + j3	  ] = initpos[0];
					reference[ i6 + j3 + 1] = initpos[1];
					reference[ i6 + j3 + 2] = initpos[2];

					rspeed[i * 6 + j] = tmprs;
					life[i * 6 + j] = plife;
				}
				verts_push(i, [
					-size, -size,  0.0*i,
					 size, -size,  0.0*i,
					 size,  size,  0.0*i,

					 size,  size,  0.0*i,
					-size,  size,  0.0*i,
					-size, -size,  0.0*i ]
				)
				var pu = Math.random() > .5 ? 0. : 0.5;
				var pv = Math.random() > .5 ? 0 : 0.5;

				uvs_push(i, [
					pu, pv,
					pu + 0.5, pv,
					pu + 0.5, pv +0.5,

					pu + 0.5, pv +0.5,
					pu, pv + 0.5,
					pu, pv]
				)
				// uvs_push(i, [
				// 	0, 0,
				// 	pu + 1, pv,
				// 	pu + 1, pv +1,

				// 	pu + 1, pv +1,
				// 	pu, pv + 1,
				// 	pu, pv]
				// )
			}
			for ( var i = 0, i3 = 0; i < vertex; i ++, i3 += 3 ) {
				// sizes[ i ] = 10;
				colors[ i3 + 0 ] = color.r;
				colors[ i3 + 1 ] = color.g;
				colors[ i3 + 2 ] = color.b;
				// positions[i3]

				if (i%3===1 || i%3 ===4) {
					colors[i3 + 1] = color.g - 0.3;
				}
			}	

			geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
			geometry.addAttribute( 'customColor', new THREE.BufferAttribute( colors, 3 ) );
			geometry.addAttribute( 'rotation', new THREE.BufferAttribute( rotations, 3 ) );
			geometry.addAttribute( 'selfspeed', new THREE.BufferAttribute( selfspeed, 3 ) );
			geometry.addAttribute( 'rspeed', new THREE.BufferAttribute( rspeed, 1 ) );
			geometry.addAttribute( 'life', new THREE.BufferAttribute( life, 1 ) );
			geometry.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );
			geometry.addAttribute( 'refer', new THREE.BufferAttribute( reference, 3 ) );

			console.log(geometry);

			particleSystem = new THREE.Mesh( geometry, shaderMaterial );

			scene.add( particleSystem );

			// Create the renderer
			renderer = new THREE.WebGLRenderer({ 
				alpha: true, 
				antialias: true 
			});
			renderer.setClearColor( 0xffffff, 0);
		    renderer.setSize(WIDTH, HEIGHT);
		 	// renderer.shadowMap.enabled = true;

			createLights();

			var container = document.getElementById( 'container' );
			container.appendChild( renderer.domElement );

			stats = new Stats();
			// container.appendChild( stats.dom );
			
			cameraControls = new THREE.OrbitControls(camera, renderer.domElement);
			cameraControls.target.set(0, 30, 0);
		
			window.addEventListener( 'resize', onWindowResize, false );

			var grid = new THREE.GridHelper(100, 10);
			
			// import tree
			var loader = new THREE.ObjectLoader();
			loader.load('sampletree.json', function(loadedObj, materials) {

			    var Texloader = new THREE.TextureLoader();
  				var texture = Texloader.load( 'wood.jpg', function ( texture ) {
				    texture.wrapS = texture.wrapT = THREE.RepeatWrapping;

				    texture.offset.set( 0, 0 );
				    texture.repeat.set( 15, 15 );

				} );
				var flowerT = Texloader.load( 'flower.png', function ( texture ) {
				    texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
				    texture.transparent=true;
				    // texutre.alphaTest= 0.5,
				    texture.offset.set( 0, 0 );
				    texture.repeat.set( 1, 1);

				} );
				console.log(loadedObj);
				var tree = loadedObj.getObjectByName("tree.001");
				var flower = loadedObj.getObjectByName("leaves");
				// tree.position.y = -20;
				flower.position.x = -60;
				tree.position.x = -60;
				// var tree1 = loadedObj.getObjectByName("tree.002");
  				var treematerial = new THREE.MeshBasicMaterial({transparent: true, map: texture});
  				var flowermaterial = new THREE.MeshBasicMaterial({transparent: true, map: flowerT});
			    // var mesh = new THREE.Mesh(loadedObj, treematerial);
			    // var flower = new THREE.Mesh(flower, flowermaterial);
			    tree.material = treematerial;
			    // flower.material = flowermaterial;
			 //    console.log(mesh);
			 //    // var tree = loadedObj.getObjectByName("Cube");
			    // tree.position.y = -10;
			    // tree1.position.y = -10;
			    scene.add(tree);
			});
			loadSkyBox();
		}
		
		document.body.onkeyup = function(e){
		    if(e.keyCode == 32){
		    	cameraControls.enabled = space;
		        space = !space;
		    	if (space) {
					document.addEventListener('mousedown', onDocumentMouseDown, true);
					document.addEventListener('mouseup', onDocumentMouseUp, true);
		    	} else {
		    		document.removeEventListener('mousedown', onDocumentMouseDown, true);
					document.removeEventListener('mouseup', onDocumentMouseUp, true);
		    	}	
		    }
		}
		function loadSkyBox() {
	        // Load the skybox images and create list of materials
	        var materials = [
	            createMaterial( 'referBG/skyX55+x.png' ), // right
	            createMaterial( 'referBG/skyX55-x.png' ), // left
	            createMaterial( 'referBG/skyX55+y.png' ), // top
	            createMaterial( 'referBG/skyX55-y.png' ), // bottom
	            createMaterial( 'referBG/skyX55+z.png' ), // back
	            createMaterial( 'referBG/skyX55-z.png' )  // front
	        ];
	         
	        // Create a large cube
	        var mesh = new THREE.Mesh( new THREE.BoxGeometry( 250, 250, 250, 1, 1, 1 ), new THREE.MeshFaceMaterial( materials ) );
	         
	        // Set the x scale to be -1, this will turn the cube inside out
	        mesh.scale.set(-1,1,1);
	        mesh.position.y = -15;
	        //scene.add( mesh );  
		}
		 
		function createMaterial( path ) {
		    var texture = THREE.ImageUtils.loadTexture(path);
		    var material = new THREE.MeshBasicMaterial( { map: texture, overdraw: 0.5 } );
		 
		    return material; 
		}

		function onWindowResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize( window.innerWidth, window.innerHeight );
		}


		function animate() {
			requestAnimationFrame( animate );
			render();
			stats.update();

		}

		function render() {
			var now = Date.now() * 0.005;
			uniforms.time.value += 1;
			uniforms.winddir.value.y += 0.01;
			var positions = geometry.attributes.position.array;
			var rotations = geometry.attributes.rotation.array;
			var plifes = geometry.attributes.life.array;
			// console.log(sizes);
			for (var i = 0, i6 = 0; i < particles * 6; i ++, i6 += 6 ) {
				// console.log(positions[i3]);
				// var plife = getRandom(50, 2000);
				if (plifes[i6] < 1050) {
					plifes[i6] += 1;
					plifes[i6 + 1] += 1;
					plifes[i6 + 2] += 1;
					plifes[i6 + 3] += 1;
					plifes[i6 + 4] += 1;
					plifes[i6 + 5] += 1;
				} else {
					plifes[i6] -= 1050;
					plifes[i6 + 1] -= 1050;
					plifes[i6 + 2] -= 1050;
					plifes[i6 + 3] -= 1050;
					plifes[i6 + 4] -= 1050;
					plifes[i6 + 5] -= 1050;
				}
				// positions[i3 + 2] +=0.3;
				// positions[ i3 + 1 ] = (positions[ i3 + 1 ] > HEIGHT)?  : positions[i3+1]-0.5;
				// rotations[i] += 0.05;
			}
			// geometry.attributes.position.needsUpdate = true;
			geometry.attributes.life.needsUpdate = true;
			renderer.render( scene, camera );
		}

	</script>

</body>
</html>