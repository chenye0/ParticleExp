<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Exp - Shader</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #ffffff;
				margin: 0px;
				overflow: hidden;
			}
			#info {
				position: absolute;
				top: 0px;
				width: 100%;
				padding: 5px;
				font-family: Monospace;
				font-size: 13px;
				text-align: center;
				font-weight: bold;
			}
			#container {
				position: absolute;
				width: 100%;
				height: 100%;
				overflow: hidden;
				background: #5963bd;
			}
			a {
				color: #fff;
			}
			button {
				position: fixed;
				z-index: 10;
				background-color: black; /* Green */
			    border: none;
			    color: white;
			    padding: 15px 15px;
			    text-align: center;
			    text-decoration: none;
			}
		</style>
	</head>

	<body>
		<button type="button" onclick="switchScene()">Switch Scene</button>
		<div id="container"></div>

		<script src="js/three.min.js"></script>
		<script type="text/javascript" src="js/OrbitControls.js"></script>
		<script src="js/Detector.js"></script>
		<!-- <script src="../three.js-dev/examples/js/libs/stats.min.js"></script> -->
		<script src="js/perlin.js"></script>
		<script type="x-shader/x-vertex" id="vertexshader">
			uniform float time;
			attribute vec3 refer;
			attribute vec3 customColor;
			attribute vec3 selfspeed;
			attribute vec3 rotation;
			attribute float rspeed;
			attribute float life;
			uniform vec3 winddir;
			uniform float windspeed;

			varying vec2 vUv;
			varying vec3 vColor;
			// varying vec3 vRotation;
			vec3 rotateX(vec3 pos, float alpha) {
			    mat4 trans= mat4(   1.0, 0.0, 0.0, 0.0, 
			                        0.0, cos(alpha), -sin(alpha), 0.0, 
			                        0.0, sin(alpha), cos(alpha), 0.0, 
			                        0.0, 0.0, 0.0, 1.0);
			    return vec3(trans * vec4(pos, 1.0));
			}

			vec3 rotateZ(vec3 pos, float alpha) {
			    mat4 trans= mat4(   cos(alpha), -sin(alpha), 0.0, 0.0, 
			                        sin(alpha), cos(alpha), 0.0, 0.0, 
			                        0.0, 0.0, 1.0, 0.0, 
			                        0.0, 0.0, 0.0, 1.0);
			    return vec3(trans * vec4(pos, 1.0));
			}

			vec3 rotateY(vec3 pos, float alpha) {
			    mat4 trans= mat4(   cos(alpha), 0.0, sin(alpha), 0.0, 
			                        0.0, 1.0, 0.0, 0.0, 
			                        -sin(alpha), 0.0, cos(alpha), 0.0, 
			                        0.0, 0.0, 0.0, 1.0);
			    return vec3(trans * vec4(pos, 1.0));
			}

			void main() {
			    // float ra = 1.0*sin(time);
			    vec3 windshift = life * windspeed * winddir;
			    vec3 selfshift = life * selfspeed;
				vec3 r = life * rspeed * rotation;
				vColor = customColor;
				vUv = uv;
				vec3 translated = position;
				vec3 rotated =  rotateX(translated, r.x);
				rotated =  rotateY(rotated, r.y);
				rotated =  rotateZ(rotated, r.z);
				translated = rotated + refer;
				vec3 finalPos = translated + windshift + selfshift;
				vec4 mvPosition = modelViewMatrix * vec4( finalPos, 1.0 );
				// gl_PointSize = 30.0 * ( 300.0 / -mvPosition.z );
				gl_Position = projectionMatrix * mvPosition;

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshader">

			uniform vec3 color;
			uniform sampler2D texture;

			varying vec3 vColor;
			varying vec2 vUv;

			void main() {
				float mid = 0.5;
				gl_FragColor = vec4( 1.0,1.0,1.0, 1.0 );
				gl_FragColor = gl_FragColor * texture2D( texture, vUv);

			}

		</script>
		<script type="application/x-glsl" id="sky-vertex">  
			varying vec2 vUV;

			void main() {  
			  vUV = uv;
			  vec4 pos = vec4(position, 1.0);
			  gl_Position = projectionMatrix * modelViewMatrix * pos;
			}
		</script>
		<script type="application/x-glsl" id="sky-fragment">  
			uniform sampler2D texture;  
			varying vec2 vUV;

			void main() {  
			  vec4 sample = texture2D(texture, vUV);
			  gl_FragColor = vec4(sample.xyz, sample.w);
			}
		</script>  

		<script>

		if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

		var renderer, clock, scene, camera, stats, pointLight;

		var particleSystem, action = {}, mixer, cat, walk, uniforms, geometry, seaPlane, skyuniforms, terrain;
		
		var group = new THREE.Group();
		var texture = ['Assets/snowflakes.png', 'Assets/flower.png'];
		var Idx = 0, space =false;

		var particles = 100;

		var WIDTH = window.innerWidth;
		var HEIGHT = window.innerHeight;

		init();

		function createLights() {
			hemisphereLight = new THREE.HemisphereLight(0xffffff,0xffffff, .6);
			pointLight = new THREE.PointLight( 0xffcc00, 1, 10 );
			pointLight.position.set( 10, 10, 10);
			
		shadowLight = new THREE.DirectionalLight(0xffffff, .5);
		shadowLight.position.set(100, 100, 100);
		shadowLight.castShadow = true;
		shadowLight.shadowDarkness = 0.2;
		shadowLight.shadowMapWidth = shadowLight.shadowMapHeight = 2048;
		shadowLight.shadow.camera.near = 0.5;       // default
		shadowLight.shadow.camera.far = 500;      // default
		shadowLight.shadowCameraLeft = -100;
		shadowLight.shadowCameraRight = 100;
		shadowLight.shadowCameraTop = 100;
		shadowLight.shadowCameraBottom = -100;

//Create a helper for the shadow camera (optional)
var helper = new THREE.CameraHelper( shadowLight.shadow.camera );
//scene.add( helper );

			scene.add(hemisphereLight);
			 var elight = new THREE.AmbientLight(0xffffff, 0.2);
  //scene.add(elight);
			scene.add(shadowLight);
		}
		function createGround() {
			var Texloader = new THREE.TextureLoader();
			// var bump = THREE.ImageUtils.loadTexture("Assets/noise.jpg");
			var snowmaterial = new THREE.MeshLambertMaterial({
				color: 0xffffff,
				// bumpMap: bump
			});
			var seageom = new THREE.PlaneBufferGeometry(200, 200, 128, 128);
			terrain = new THREE.Mesh(seageom, snowmaterial);
			// get the vertices
			// const Perlin = require('./perlin.js').Perlin;
			var perlin = new SimplexNoise(); 
			var peak = 1;
			var smoothing = 100;
			var vertices = terrain.geometry.attributes.position.array;
			for (var i = 0; i <= vertices.length; i += 3) {
			    vertices[i+2] = peak * perlin.noise(
			        vertices[i]/smoothing, 
			        vertices[i+1]/smoothing
			    );
			}
			terrain.geometry.attributes.position.needsUpdate = true;
			terrain.geometry.computeVertexNormals();
			terrain.rotation.x = -90 * Math.PI/180;
			terrain.receiveShadow = true;

			scene.add(terrain);

		}

		function createParticle() {
			uniforms = {
				time: { value: 10.0 },
				winddir: { value: new THREE.Vector3( 0.3, -2, 0.3) },
				windspeed: { value: 0.1 },
				color:     { value: new THREE.Color( 0xffffff ) },
				texture:   { value: new THREE.TextureLoader().load( texture[0] ), transparent: true, opacity: 0.1 }
			};

			var particleMaterial = new THREE.ShaderMaterial( {

				uniforms:       uniforms,
				vertexShader:   document.getElementById( 'vertexshader' ).textContent,
				fragmentShader: document.getElementById( 'fragmentshader' ).textContent,

				side:           THREE.DoubleSide,
				depthTest:      false,
				transparent:    true
			});

			var radius = 200;
			var triangles = particles * 2;
			var vertex = triangles * 3;

			geometry = new THREE.BufferGeometry();

			var color = new THREE.Color(0xffcc99);
			var positions = new Float32Array( vertex * 3); 
			var colors = new Float32Array( vertex * 3);
			var uvs = new Float32Array ( vertex * 2);
			var rotations = new Float32Array( vertex * 3 ); // vertex / 2
			var rspeed = new Float32Array( vertex);
			var life = new Float32Array( vertex);
			var selfspeed = new Float32Array( vertex * 3 ); // vertex / 2
  			var reference = new Float32Array( vertex * 3);

			function verts_push(p, arr) {
				var v = p * 18;
				for (var i=0; i < arr.length; i++) {
					positions[v++] = arr[i];
				}
			}
			function uvs_push(p, arr) {
				var v = p * 12;
				for (var i=0; i < arr.length; i++) {
					uvs[v++] = arr[i];
				}
			}
			function getRandom(min, max) {
			    return Math.random() * (max - min) + min;
			}

			for (var i = 0, i6 = 0; i < particles; i ++, i6+= 18) {
				var tmpr = [getRandom(-1.0, 1.0), 0, getRandom(-1, 1)];
				var tmprs = getRandom(-0.1, 0.1);
				var selfs = [getRandom(-0.01, 0.01), getRandom(0, 0.01), getRandom(-0.01, 0.01)];
				// var initpos = [getRandom(-20.0, 20.0), getRandom(10.0, 20.0), getRandom(-10.0, 10.0)],
				var initpos = [getRandom(-150.0, 150.0),100,getRandom(-150.0, 150.0)],
					plife = getRandom(100, 2000);
				var size =  1;

				for (var j =0, j3 = 0; j < 6; j ++, j3 += 3) {
					rotations[i6 + j3    ] =  tmpr[0];
					rotations[i6 + j3 + 1] =  tmpr[1];
					rotations[i6 + j3 + 2] =  tmpr[2];

					selfspeed[i6 + j3    ] =  selfs[0];
					selfspeed[i6 + j3 + 1] =  selfs[1];
					selfspeed[i6 + j3 + 2] =  selfs[2];

					reference[ i6 + j3	  ] = initpos[0];
					reference[ i6 + j3 + 1] = initpos[1];
					reference[ i6 + j3 + 2] = initpos[2];

					rspeed[i * 6 + j] = tmprs;
					life[i * 6 + j] = plife;
				}
				verts_push(i, [
					-size, -size,  0.0*i,
					 size, -size,  0.0*i,
					 size,  size,  0.0*i,

					 size,  size,  0.0*i,
					-size,  size,  0.0*i,
					-size, -size,  0.0*i ]
				)
				var pu = Math.random() > .5 ? 0. : 0.5;
				var pv = Math.random() > .5 ? 0 : 0.5;

				uvs_push(i, [
					pu, pv,
					pu + 0.5, pv,
					pu + 0.5, pv +0.5,

					pu + 0.5, pv +0.5,
					pu, pv + 0.5,
					pu, pv]
				)
			}
			for ( var i = 0, i3 = 0; i < vertex; i ++, i3 += 3 ) {
				// sizes[ i ] = 10;
				colors[ i3 + 0 ] = color.r;
				colors[ i3 + 1 ] = color.g;
				colors[ i3 + 2 ] = color.b;
				// positions[i3]
				if (i%3===1 || i%3 ===4) {
					colors[i3 + 1] = color.g - 0.3;
				}
			}	

			geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
			geometry.addAttribute( 'customColor', new THREE.BufferAttribute( colors, 3 ) );
			geometry.addAttribute( 'rotation', new THREE.BufferAttribute( rotations, 3 ) );
			geometry.addAttribute( 'selfspeed', new THREE.BufferAttribute( selfspeed, 3 ) );
			geometry.addAttribute( 'rspeed', new THREE.BufferAttribute( rspeed, 1 ) );
			geometry.addAttribute( 'life', new THREE.BufferAttribute( life, 1 ) );
			geometry.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );
			geometry.addAttribute( 'refer', new THREE.BufferAttribute( reference, 3 ) );

			particleSystem = new THREE.Mesh( geometry, particleMaterial );

			//scene.add( particleSystem );

		}
		function load3dmodel() {

			// import tree
			var loader = new THREE.JSONLoader();	
			loader.load('Cat2.json', function(geometry, materials) {
				// materials.forEach(function(mat) {
				// 	mat.skinning = true;
				// })
			    cat = new THREE.Mesh( geometry, new THREE.MeshFaceMaterial( materials ) );
	
			       scene.add(cat);
			    //materials[ 0 ].shading = THREE.FlatShading;
			    // cat.shading = 
			    cat.castShadow=true;
			    
			    // mixer = new THREE.AnimationMixer(cat);
			    
			    // action.walk = mixer.clipAction(geometry.animations[ 1 ]);
			    // action.walk.setEffectiveWeight(1);
		
			   	// action.walk.enabled = true;
			   	// action.walk.clampWhenFinished = true;

			    scene.add(cat);

			   	animate();
				//console.log(action.walk)
			    cat.position.set(0, -0.1, 0);
			    isLoaded = true;

			    //action.walk.play();

			});
		}
		function createSky() {
			var skyGeo = new THREE.SphereGeometry(200, 40, 25); 
			skyuniforms = {  
			  texture: { type: 't', value: THREE.ImageUtils.loadTexture('Assets/darksky.jpg') }
			};
			var skymat = new THREE.ShaderMaterial( {  
				uniforms:       skyuniforms,
				vertexShader:   document.getElementById('sky-vertex').textContent,
				fragmentShader: document.getElementById('sky-fragment').textContent
			});

			var skyBox = new THREE.Mesh(skyGeo, skymat);
		    skyBox.scale.set(-1, 1, 1);  
			skyBox.eulerOrder = 'XZY';  
			skyBox.renderDepth = 1000.0;  
			//scene.add(skyBox); 
		}
		function switchScene() {
			console.log(Idx);
			Idx < 2 ? Idx += 1 : Idx = 0;
			uniforms.texture.value = new THREE.TextureLoader().load( texture[Idx] );
			particleSystem.material.needsUpdate = true;
		}

		function init() {
			camera = new THREE.PerspectiveCamera( 40, WIDTH / HEIGHT, .1, 1000 );
			camera.position.x = -20;
			camera.position.y = 5;
			clock = new THREE.Clock();
			scene = new THREE.Scene();
			createGround();
			createSky();
			createParticle();
			createLights();
			load3dmodel();
			renderer = new THREE.WebGLRenderer({ 
				alpha: true, 
				antialias: true 
			});
			renderer.setClearColor( 0xffffff, 0);
		    renderer.setSize(WIDTH, HEIGHT);
		    renderer.shadowMapEnabled = true;
		    // renderer.shadowMapSoft = true;

			var container = document.getElementById( 'container' );
			container.appendChild( renderer.domElement );
			
			cameraControls = new THREE.OrbitControls(camera, renderer.domElement);
			cameraControls.target.set(0, 0, 0);


			// cameraControls.minPolarAngle = Math.PI/4; // radians
			// cameraControls.maxPolarAngle = Math.PI/2 + 0.1; // radians
			// cameraControls.minDistance = 30;
			// cameraControls.maxDistance = 300;
		
			window.addEventListener( 'resize', onWindowResize, false );

		}
		

		function onWindowResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize( window.innerWidth, window.innerHeight );
		}

		function animate() {
			// cat.position.z += 0.01;
			requestAnimationFrame( animate );
			// console.log('here');
			render();
		}

		function render() {
		  var delta = clock.getDelta();
		  //mixer.update(delta/2);
		  renderer.render(scene, camera);
		}
	</script>

</body>
</html>